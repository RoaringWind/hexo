---
title: 计算机网络知识点总结
date: 2021-04-13 15:18:35
tags: [计算机网络]
---

# 路由器和交换机位于哪一层

路由器：网络层

交换机：数据链路层

# 滑动窗口的实现机制

## 发送方的四种数据

1. Sent and Acknowledged：这些数据表示已经发送成功并已经被确认的数据，比如图中的前31个bytes，这些数据其实的位置是在窗口之外了，因为窗口内顺序最低的被确认之后，要移除窗口，实际上是窗口进行合拢，同时打开接收新的带发送的数据
2. Send But Not Yet Acknowledged：这部分数据称为发送但没有被确认，数据被发送出去，没有收到接收端的ACK，认为并没有完成发送，这个属于窗口内的数据。
3. Not Sent，Recipient Ready to Receive：这部分是尽快发送的数据，这部分数据已经被加载到缓存中，也就是窗口中了，等待发送，其实这个窗口是完全有接收方告知的，接收方告知还是能够接受这些包，所以发送方需要尽快的发送这些包
4. Not Sent，Recipient Not Ready to Receive： 这些数据属于未发送，同时接收端也不允许发送的，因为这些数据已经超出了接受端所接收的范围

## 接收方的三种数据

1. Received and ACK Not Send to Process：这部分数据属于接收了数据，已经回复了。但是还没有被上层的应用程序接收，也是被缓存在窗口内
2. Received  Not ACK: 已经接收并，但是还没有回复ACK，这些包可能输属于Delay ACK的范畴了
3. Not Received：有空位，还没有被接收的数据。

# IP和TCP传输的都是些什么数据

## IP

### 头部分

IP版本，长度，服务类型，源/目的IP地址。偏移，校验和，TTL。

### 数据部分

TCP包

## TCP

### 头部分

源/目的端口号，序号，确认号，6个标志位，校验和。

### 数据部分

应用层数据。

# 如何将一个长URL转换为一个短URL

[参考]: https://kknews.cc/code/vy6mj32.html

1. HashMap 短地址长地址一一对应（最烂）
2. 短转长，但不存在逆运算（比较烂）
3. hash后如果碰撞，后面加123；或者碰撞后多次hash（一般烂）
4. **<font color=red>使用发号策略，长地址发号一个短地址</font>**。（最好）
   - 使用MySQL的自增索引。比如0-9,a-z,A-Z实现62位进制的自增。保存可以用十进制，需要的时候转62位即可。
   - 高并发可用：n个发号器，每个发号器每次增长n而不是1。
   - 长查短：保存最近生成的一些对应关系，一定时间或者一定数量后开始淘汰。
   - 跳转可以用301或者302。301可以减少服务器压力，302的话可以统计次数，原因见下。

# 分析一个URL各个字段的含义

协议://IP:端口/具体地址

# 如果没有http2.0 如何解决短连接问题

# http状态码301和302的具体区别

在搜索引擎角度，301的话，前后两个网址的PageRank是不一样的，新网址需要重新累加PageRank。302的话前后网址视作和前面一样的同一个。排名也是。

对客户端来说，301的话，会永久记住新网址，如果加到书签，下次访问就是新的了。而302的话每次都得重新请求。

HTTP到HTTPS必须用301。

# 抓包工具的原理

**抓包工具会在网络传输的某个层次或节点截获收发的数据**

如http代理，chrome的network。

# HTTP报文格式

![image-20210331100008433](C:\Users\blood\AppData\Roaming\Typora\typora-user-images\image-20210331100008433.png)

# http2.0针对http1.1的优化有哪些

[参考]: https://www.zhihu.com/question/306768582

|                      | HTTP/2                                                | HTTP1.1      |
| -------------------- | ----------------------------------------------------- | ------------ |
| **传输协议**         | <font color=red>二进制</font>                         | 文本         |
| **头部信息**         | <font color=red>压缩</font>                           | 未压缩的文本 |
| **各字段长度**       | <font color=red>固定</font>                           | 不固定       |
| **多路复用**         | <font color=red>是</font>                             | 否           |
| **连接与请求的关系** | 单个连接可以发送<font color=red>多个请求和响应</font> | 只能一个     |
| **服务器推送**       | <font color=red>支持</font>                           | 否           |

# http1.1的性能瓶颈

- 只能逐个顺序响应请求报文，前一个响应未完成就只能一直阻塞等待而无法传输下一个响应报文，这就白白浪费了TCP 连接的带宽资源，同时带来了队头阻塞问题。

- 重复传输臃肿的首部字段，降低了网络资源利用率。
- 各字段长度不固定，解析不容易。
- 只能客户端发起请求。

# http1.1相比于http1.0的优化

- **持久连接**
- 请求管道化，即流水线化，可以不用等待回复就发请求。
- 增加缓存处理（新的字段如cache-control）
- 增加Host字段、支持断点传输等

# 对称加密和非对称加密的区别，对称加密是如何保证安全性的

# http1.1新增了哪几种请求方法

OPTIONS、PUT、PATCH、DELETE、TRACE 和CONNECT 方法

| 序号 | 方法    | 描述                                                         |
| :--- | :------ | :----------------------------------------------------------- |
| 1    | GET     | 请求指定的页面信息，并返回实体主体。<font color=red>是幂等的方法</font> |
| 2    | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| 3    | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。<font color=red>不是幂等的方法</font> |
| 4    | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。<font color=red>是幂等的方法</font> |
| 5    | DELETE  | 请求服务器删除指定的页面。                                   |
| 6    | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |
| 7    | OPTIONS | 允许客户端查看服务器的性能。                                 |
| 8    | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |
| 9    | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |

# http有哪些常见的请求方法 创建一篇文章用什么请求方法

应该用POST，因为文章创建了不能再创建，应该是非幂等的。

# tcp怎么判断丢包

超时，或者接到对一个seq的包的连续3个ACK。

# http协议中的cookie和session是什么

参考：http://www.ityouknow.com/it/2019/05/11/cookie-session.html

参考：https://segmentfault.com/a/1190000017831088

- cookie只是实现session的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中

**不要混淆 session 和 session 实现。**

本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。

 而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。

而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。

所以 cookie 和 session，你可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。

# ping实现的原理

发送ICMP报文

# 什么是ICMP

ICMP协议的功能主要有：

1. 确认IP包是否成功到达目标地址
2. 通知在发送过程中IP包被丢弃的原因

tracert和ping命令用ICMP

# 为什么要三次握手

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费